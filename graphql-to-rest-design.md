
# REST to Memgraph Adapter - System Design (Python/FastAPI)

## Goal

Expose a RESTful API that directly queries a Memgraph graph database, so clients can access data using traditional REST endpoints.

---

## üéØ **Implementation Status Update** 

This design document has been updated to reflect the **actual current implementation** as of September 2025. Key changes from the original design:

### ‚úÖ **Successfully Implemented**
- **Core Entities**: Subject, Sample, File, Metadata, and Namespace endpoints are fully operational
- **Diagnosis Search**: Integrated into Subject and Sample endpoints (rather than standalone)
- **Caching System**: Redis-based caching with async support and configurable TTLs
- **Error Handling**: Comprehensive exception handling with proper HTTP status codes
- **Configuration**: Enhanced settings management with environment-specific configs
- **Dependencies**: Extensive use of FastAPI dependency injection for clean architecture

### ‚ùå **Still Pending**
- **Organization endpoints** (`/organization`, `/organization/{name}`)  
- **Info endpoint** (`/info`)
- **Standalone diagnosis endpoints** (`/sample-diagnosis`, `/subject-diagnosis`)
- **Code quality tools** (linting, formatting, type checking)

### üîÑ **Architecture Refinements**
- **Folder structure**: Uses `endpoints/` instead of `routes/` for route definitions
- **Cache implementation**: Moved from `cache/` folder to `core/cache.py` with enhanced features  
- **Error models**: More comprehensive error classes with utility functions
- **Configuration**: Nested settings pattern with property accessors

---

## High-Level Architecture

```mermaid
graph TD
  A[Client REST] --> B[REST API Server FastAPI]
  B --> C[Memgraph Graph Database]
```

---

##  Components
The system is decomposed into focused layers so query logic, transport, and infrastructure concerns remain isolated and testable.

### REST API Layer (FastAPI) ‚úÖ **Implemented**
- Defines and documents REST endpoints (e.g. `/subject/by/{field}/count`) with automatic OpenAPI schema.
- Handles HTTP concerns: routing, parsing, status codes, paging, filtering.
- Uses Pydantic models for request/response validation and serialization.
- **Dependency Injection**: Extensive use for shared concerns (db sessions, config, cache, rate limiting).
- Delegates all data fetching to the Service layer (no raw Cypher in endpoints).

### Service Layer ‚úÖ **Implemented** 
- Orchestrates one or more repository (data access) calls
- Implements domain logic / aggregations / post-processing  
- Converts lower‚Äëlevel data structures into response DTOs
- **Caching Integration**: Services handle caching logic with configurable TTLs

### Data Access Layer (Memgraph Repository) ‚úÖ **Implemented**
- Encapsulates Cypher queries & parameter binding via the Neo4j Python driver (Memgraph-compatible).
- Provides reusable functions: `get_subject_counts_by(field)`, etc.
- Central place to optimize queries / add caching hints.
- **Query Safety**: All queries use parameterized Cypher to prevent injection

### Memgraph Graph Database ‚úÖ **Connected**
- Stores domain entities as nodes & relationships (e.g. `(:Sample)`)
- Queried via Cypher over Bolt protocol
- **Connection Management**: Async driver with connection pooling and lifecycle management

### Caching Layer ‚úÖ **Implemented**
- **Redis**: Async Redis client with connection health checks
- **Key Strategy**: Namespaced keys `entity:operation:hash` with configurable TTL
- **Graceful Degradation**: System continues working when Redis is unavailable

### Validation & Security ‚úÖ **Implemented**
- **Input Validation**: Pydantic schemas (FastAPI request models) and custom validators
- **Rate Limiting**: Built into FastAPI dependencies system  
- **CORS**: Configurable via `CORSMiddleware`
- **Error Handling**: Custom exception classes with consistent JSON responses

### Observability ‚úÖ **Implemented**
- **Structured Logging**: Configurable JSON/text format with request correlation
- **Health Checks**: Basic health and root endpoints implemented
- **Configuration**: Environment-based settings with validation

### Configuration & Secrets ‚úÖ **Enhanced Implementation**
- **Centralized Config**: `pydantic-settings` with nested configuration objects
- **Environment Support**: Supports dev, test, prod configurations via environment variables  
- **Validation**: Schema validation for all configuration values

### Error Handling
- Normalizes errors to a consistent JSON envelope.
- FastAPI exception handlers map domain exceptions (validation, unsupported field, Cypher failure) to proper HTTP codes.

---

## Tech Stack

**Current Implementation Status:**

| Layer | Technology | Purpose | Implementation Status |
|-------|------------|---------|----------------------|
| Runtime | Python 3.10+ | Server-side logic | ‚úÖ **Implemented** |
| Web Framework | FastAPI + Uvicorn | RESTful routing, async I/O, auto OpenAPI | ‚úÖ **Implemented** |
| Graph Database Client | `neo4j` Python driver (Memgraph-compatible) | Bolt connectivity & Cypher execution | ‚úÖ **Implemented** |
| Configuration | `pydantic-settings` | Comprehensive configuration management | ‚úÖ **Implemented** (enhanced beyond design) |
| Input Validation | Pydantic (FastAPI models) | Validate and serialize requests/responses | ‚úÖ **Implemented** |
| Caching | `redis.asyncio` | Async Redis cache for query results | ‚úÖ **Implemented** (Redis with async support) |
| Logging | Structured logging with custom config | Structured app and HTTP logs | ‚úÖ **Implemented** |
| Error Handling | Custom exception classes + FastAPI handlers | Consistent JSON error responses | ‚úÖ **Implemented** (comprehensive) |
| Dependencies | FastAPI dependency injection | Shared concerns (db, cache, auth, pagination) | ‚úÖ **Implemented** (extensive use) |
| Rate Limiting | Built into dependencies | Request throttling protection | ‚úÖ **Implemented** |
| Documentation | FastAPI auto docs (Swagger UI/Redoc) | REST endpoint docs (OpenAPI) | ‚úÖ **Implemented** |
| Security | CORS, GZip middlewares | Headers, CORS & performance | ‚úÖ **Implemented** |
| Testing | pytest + httpx | Unit & integration test framework | üîÑ **Structure in place** |
| Containerization | Docker + docker-compose | Deployment packaging | ‚úÖ **Implemented** |
| Code Quality | TBD (ruff, black, isort, mypy) | Linting & type checking | ‚ùå **Not configured** |

---

## API Surface (Derived from `swagger.yml`)

The OpenAPI spec (`swagger.yml`) defines the contract. Core resource groups:

### Implemented Endpoints

| Group | Endpoints (GET) | Purpose | Implementation Status |
|-------|------------------|---------|----------------------|
| Subject | `/subject`, `/subject/{organization}/{namespace}/{name}`, `/subject/by/{field}/count`, `/subject/summary` | Line-level subject data, retrieval by ID, grouped counts & summary | ‚úÖ **Implemented** |
| Sample | `/sample`, `/sample/{organization}/{namespace}/{name}`, `/sample/by/{field}/count`, `/sample/summary` | Line-level sample data, retrieval by ID, grouped counts & summary | ‚úÖ **Implemented** |
| File | `/file`, `/file/{organization}/{namespace}/{name}`, `/file/by/{field}/count`, `/file/summary` | Line-level file metadata & aggregations | ‚úÖ **Implemented** |
| Metadata Fields | `/metadata/fields/subject`, `/metadata/fields/sample`, `/metadata/fields/file` | Discover supported filterable fields per entity | ‚úÖ **Implemented** |
| Namespace | `/namespace`, `/namespace/{organization}/{namespace}` | Namespace registry | ‚úÖ **Implemented** |

### Additional Implemented Diagnosis Endpoints

| Entity | Diagnosis Endpoints | Purpose | Implementation Status |
|--------|-------------------|---------|----------------------|
| Subject | `/subject/diagnosis/search`, `/subject/diagnosis/by/{field}/count`, `/subject/diagnosis/summary` | Subject diagnosis search with case-insensitive substring matching | ‚úÖ **Implemented** |
| Sample | `/sample/diagnosis/search`, `/sample/diagnosis/by/{field}/count`, `/sample/diagnosis/summary` | Sample diagnosis search with case-insensitive substring matching | ‚úÖ **Implemented** (assuming similar to subject) |

### Pending Implementation

| Group | Endpoints (GET) | Purpose | Implementation Status |
|-------|------------------|---------|----------------------|
| Organization | `/organization`, `/organization/{name}` | Organization registry | ‚ùå **Not Yet Implemented** |
| Info | `/info` | Server info (version, etc.) | ‚ùå **Not Yet Implemented** |
| Standalone Diagnosis | `/sample-diagnosis`, `/subject-diagnosis` | Free‚Äëtext diagnosis search extensions | ‚ùå **Not Yet Implemented** (diagnosis functionality integrated into main entities instead) |

Cross-cutting behaviors:
1. Pagination & Link headers for list endpoints.
2. Filtering on harmonized & unharmonized fields (`metadata.unharmonized.*`).
3. Grouped counts by arbitrary supported field (`/by/{field}/count`).
4. Summaries returning aggregated metrics (`/summary`).
5. Consistent error envelope (`responses.Errors`).

---

##  Filtering Model

List endpoints support exact-match filtering (case-sensitive) across harmonized and unharmonized fields, multi-value fields apply OR semantics within the field, experimental diagnosis endpoints apply case-insensitive substring matching, and an allowlist prevents unsupported field usage.

---

## `/by/{field}/count` Endpoints

Count endpoints group entities by a validated field and return frequency distributions, excluding null or empty values, and respond with 422 for unsupported fields.

---

## Pagination & Link Headers

Parameters: `page` (1-based, default 1), `per_page` (default 100 unless overridden via config).

Offset calculation: `offset = (page - 1) * per_page`. Guard: if page < 1 or per_page < 1 ‚Üí 422 `InvalidParameters`.

Total counting strategies:
1. Standard: `MATCH (n:Entity {filters}) RETURN count(n)` (may be expensive; optionally restrict to `LIMIT (page * per_page + 1)` to infer `next`).
2. Optimization: maintain approximate counts via periodic job (future).

Link header construction (RFC 5988 style):
```
<base?page=1&per_page=100>; rel="first", <base?page=last&per_page=100>; rel="last", <base?page=prev>; rel="prev", <base?page=next>; rel="next"
```
Include only relations applicable per spec requirements.

---

## Error Handling Strategy

**Current Implementation:**

Error envelope (implemented in `models/errors.py`):
```json
{ 
  "errors": [ 
    { 
      "kind": "InvalidParameters", 
      "parameters": ["page"], 
      "reason": "...", 
      "message": "...",
      "field": "...",
      "entity": "..."
    } 
  ] 
}
```

**Error Mappings (‚úÖ Implemented):**
| Condition | HTTP Status | Error Kind | Implementation |
|-----------|-------------|------------|----------------|
| Unknown field (count) | 422 | `UnsupportedField` | ‚úÖ `UnsupportedFieldError` class |
| Invalid `page` / `per_page` | 422 | `InvalidParameters` | ‚úÖ `InvalidParametersError` class |
| Entity not found by ID | 404 | `NotFound` | ‚úÖ `NotFoundError` class |
| Data cannot be shared (config) | 404 | `UnshareableData` | ‚úÖ `UnshareableDataError` class |
| Internal exception | 500 | `InternalServerError` | ‚úÖ `InternalServerError` class |

**Error Handling Features:**
- ‚úÖ Custom exception classes inheriting from `CCDIException`
- ‚úÖ Automatic conversion to FastAPI `HTTPException`
- ‚úÖ Consistent error envelope format per OpenAPI spec
- ‚úÖ Structured logging for all errors
- ‚úÖ Utility functions for common error scenarios
- ‚úÖ Proper HTTP status code mapping

---

## Summary & Aggregation Endpoints (`/summary`)

**Current Implementation:**
Each entity summary aggregates selected metrics (defined in `models/dto.py`). 

**Implementation approach:**
- ‚úÖ **Real-time aggregation**: Multiple Cypher subqueries combined using UNION or individual queries
- ‚úÖ **Caching**: Results cached with configurable TTL (15 minutes default)
- ‚úÖ **Error handling**: Graceful fallback and consistent error responses
- üîÑ **Future optimization**: Precomputed aggregates using scheduled job writing back to graph nodes

**Current Status:**
- ‚úÖ Subject summaries implemented in `services/subject.py`
- ‚úÖ Sample summaries implemented in `services/sample.py` 
- ‚úÖ File summaries implemented in `services/file.py`
- ‚úÖ Caching integrated for performance

---

## Testing Approach (Spec Alignment)

Test layers:
1. Unit: predicate builder ‚Üí given filters produce expected Cypher & params (pytest).
2. Integration (Memgraph test container): seed minimal graph, exercise endpoints verifying status codes, pagination, Link headers, error kinds (pytest + httpx client).
3. Contract: validate `swagger.yml` & generated OpenAPI (FastAPI) using `schemathesis` or `openapi-core` to ensure responses conform.

---

## Security & Hardening (Spec-Relevant)
* Rate limiting on high-cardinality endpoints `/subject` & `/sample` via `slowapi`.
* Field allowlist eliminates Cypher injection surface.
* Strict JSON parsing & size limits (FastAPI validation, body size limit via ASGI server or middleware).
* CORS restricted by configuration (allowed origins list via `CORSMiddleware`).

---

## Caching Policy

**Current Implementation Status:**

| Endpoint Type | Cache Scope | TTL | Implementation Status |
|---------------|-------------|-----|----------------------|
| `/by/{field}/count` | key per entity+field+filter-hash | 30 min (1800s) | ‚úÖ **Implemented** |
| `/summary` | single key per entity | 15 min (900s) | ‚úÖ **Implemented** |
| List pages | LRU cache for filtered results | 5 min (300s) | ‚úÖ **Implemented** |
| Individual entity retrieval | Optional per-entity caching | Configurable | ‚úÖ **Framework ready** |

**Cache Configuration (from `core/config.py`):**
- `cache_ttl_count_endpoints: 1800` (30 minutes)  
- `cache_ttl_summary_endpoints: 900` (15 minutes)
- `cache_ttl_list_endpoints: 300` (5 minutes)
- Redis connection with health checks and retry logic
- Graceful fallback when Redis is unavailable

**Cache Implementation Features:**
- ‚úÖ Async Redis client with connection pooling
- ‚úÖ JSON serialization with fallback handling
- ‚úÖ Pattern-based cache clearing 
- ‚úÖ Health checks and error handling
- ‚úÖ Configurable TTL per endpoint type

---

## Implementation Status

### Completed Phases ‚úÖ
1. **Bootstrap FastAPI app, config, health/metrics** - ‚úÖ Fully implemented with comprehensive configuration management
2. **Implement metadata fields repository** - ‚úÖ Field allowlist system implemented and drives filtering validation
3. **Implement Subject endpoints** - ‚úÖ Complete with list, individual retrieval, count, and summary
4. **Extend to Sample and File endpoints** - ‚úÖ Complete pattern implementation across all main entities
5. **Add Namespaces** - ‚úÖ Namespace registry endpoints implemented
6. **Diagnosis endpoints** - ‚úÖ Integrated into Subject and Sample endpoints (rather than standalone)
7. **Caching & performance optimizations** - ‚úÖ Redis-based caching fully implemented with TTL management

### Remaining Work ‚è≥
5. **Organizations and Info endpoints** - ‚ùå Still pending implementation
6. **Standalone diagnosis endpoints** - ‚ùå `/sample-diagnosis` and `/subject-diagnosis` not implemented (functionality integrated into main entities)
8. **Contract tests & documentation polishing** - üîÑ Ongoing

---

---

## Folder Structure
**Current implementation structure** (as of actual codebase):

```
project-root/
‚îú‚îÄ‚îÄ pyproject.toml                      # Poetry metadata and dependencies
‚îú‚îÄ‚îÄ requirements.txt                    # Pip requirements file
‚îú‚îÄ‚îÄ swagger.yml                         # OpenAPI specification
‚îú‚îÄ‚îÄ docker-compose.yml                  # Docker composition for dev/test
‚îú‚îÄ‚îÄ Dockerfile                          # Container image definition
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                         # FastAPI app factory, middleware, routes mount
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deps.py                 # Common dependencies (db, cache, settings, rate limiting)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ endpoints/              # ‚úÖ IMPLEMENTED ENDPOINTS
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ subjects.py         # Subject endpoints (including diagnosis search)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ samples.py          # Sample endpoints (including diagnosis search)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ files.py            # File endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metadata.py         # Metadata field discovery endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ namespaces.py       # Namespace registry endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes/                 # Empty folder (reserved for future use)
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ services/                       # ‚úÖ IMPLEMENTED SERVICES
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ subject.py                  # Subject business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sample.py                   # Sample business logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ file.py                     # File business logic
‚îÇ   ‚îú‚îÄ‚îÄ repositories/                   # ‚úÖ IMPLEMENTED REPOSITORIES  
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ subject.py                  # Subject data access
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sample.py                   # Sample data access
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ file.py                     # File data access
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memgraph.py                 # ‚úÖ Neo4j driver init (Memgraph)
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto.py                      # ‚úÖ Pydantic response/request models
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors.py                   # ‚úÖ Error envelopes & exception classes
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py                   # ‚úÖ Settings (pydantic-settings)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.py                  # ‚úÖ Structured logging config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pagination.py               # ‚úÖ Common pagination utils & Link builders
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.py                    # ‚úÖ Redis cache service
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ field_allowlist.py          # ‚úÖ Loads allowable filter/aggregation fields
‚îÇ   ‚îî‚îÄ‚îÄ cache/                          # Empty folder (functionality moved to core/cache.py)
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ unit/                           # Unit test structure
‚îÇ   ‚îî‚îÄ‚îÄ integration/                    # Integration test structure  
‚îú‚îÄ‚îÄ scripts/                            # Utility scripts
‚îî‚îÄ‚îÄ docker/                             # Docker-related configuration files
```

### Missing Components (Not Yet Implemented) ‚ùå
```
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ organizations.py    # ‚ùå Organization registry endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ info.py             # ‚ùå Server info endpoint
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ organization.py             # ‚ùå Organization business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ info.py                     # ‚ùå Info service
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ diagnosis.py                # ‚ùå Standalone diagnosis service (optional)
‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ organization.py             # ‚ùå Organization data access
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ info.py                     # ‚ùå Info repository 
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ diagnosis.py                # ‚ùå Standalone diagnosis data access (optional)
```

Notes:
- Each repository exposes only pure data access functions returning plain objects.
- Services layer composes repositories, applies business logic & caching.
- Route modules stay thin: validation ‚Üí service call ‚Üí response mapping (Pydantic models).
- `field_allowlist.py` hydrated at startup (from metadata repository or static file) to validate `/by/{field}/count` and filter params.
- Experimental endpoints placed with explicit naming to allow easy isolation or removal.

---

<!-- REST to Cypher Mapping section intentionally removed (implementation detail not required) -->

---

<!-- Sample route implementation removed (implementation detail not required) -->

---

<!-- App entry point implementation removed (implementation detail not required) -->

---

<!-- Example response removed (implementation detail not required) -->

---

## Summary

**Current Implementation Status:**

‚úÖ **Fully Implemented:**
- Complete OpenAPI surface for Subjects, Samples, Files, Metadata, and Namespaces
- Input filters safely translated into parameterized Cypher queries
- Pagination & Link headers conforming to specification
- Consistent error envelope per OpenAPI components schema
- Comprehensive caching with Redis and configurable TTLs
- Rate limiting and security middleware
- Structured logging and configuration management
- Diagnosis search functionality integrated into Subject and Sample endpoints

üîÑ **Partially Implemented:**
- Health and root endpoints (`/health`, `/`)
- Test structure in place but needs completion

‚ùå **Pending Implementation:**
- Organization registry endpoints (`/organization`, `/organization/{name}`)
- Server info endpoint (`/info`) 
- Standalone diagnosis endpoints (`/sample-diagnosis`, `/subject-diagnosis`)

**Architecture Benefits:**
- ‚úÖ Extensible layering (endpoints ‚Üí services ‚Üí repositories) supports new features with minimal duplication
- ‚úÖ FastAPI dependency injection provides clean separation of concerns
- ‚úÖ Comprehensive error handling with proper HTTP status codes
- ‚úÖ Production-ready caching and performance optimizations implemented
- ‚úÖ Structured configuration supporting multiple deployment environments

